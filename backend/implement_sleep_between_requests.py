#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Script com exemplos de como implementar sleep/aguardo entre requisi√ß√µes do Gemini
print("==== IMPLEMENTA√á√ÉO DE SLEEP ENTRE REQUISI√á√ïES ====")
print("\nEste script cont√©m exemplos prontos para serem copiados para o seu c√≥digo")
print("para adicionar sleep/aguardo entre requisi√ß√µes do Gemini, evitando rate limiting.")
print("\nüìã O QUE VOC√ä DEVE FAZER:")
print("1. Copie os trechos de c√≥digo abaixo para os respectivos arquivos do seu sistema")
print("2. Substitua as fun√ß√µes originais pelas vers√µes com sleep/aguardo")
print("3. Reinicie o backend ap√≥s as altera√ß√µes")
print("\n----------------------------------------")
print("\n1. PARA A FUN√á√ÉO generate_script_chapters_with_gemini_no_retry NO ARQUIVO services/ai_services.py:")
print("\n# C√≥digo a ser implementado:")
print("import time")
print("")
print("def generate_script_chapters_with_gemini_no_retry(title, context, num_chapters, api_key):")
print("    \"\"\"Gerar roteiro usando Gemini com sleep entre requisi√ß√µes para evitar rate limiting\"\"\"")
print("    import google.generativeai as genai")
print("    import sys")
print("    import os")
print("    ")
print("    # Adicionar o diret√≥rio routes ao path para importar fun√ß√µes")
print("    sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'routes'))")
print("    ")
print("    try:")
print("        # Configurar Gemini")
print("        genai.configure(api_key=api_key)")
print("        model = genai.GenerativeModel('gemini-1.5-flash')")
print("        ")
print("        print(f\"üîÑ Enviando prompt para Gemini (t√≠tulo: {title[:30]}...)\")")
print("        ")
print("        # Criar prompt")
print("        prompt = f\"\"\"")
print("        Voc√™ √© um roteirista experiente de YouTube...")
print("        [SEU PROMPT AQUI]")
print("        \"\"\"")
print("        ")
print("        # Enviar requisi√ß√£o para a API")
print("        response = model.generate_content(prompt)")
print("        ")
print("        # SLEEP DE 1 SEGUNDO AP√ìS CADA REQUISI√á√ÉO PARA EVITAR RATE LIMITING")
print("        time.sleep(1)")
print("        ")
print("        if not response.text:")
print("            return {")
print("                'success': False,")
print("                'error': 'Gemini n√£o retornou conte√∫do'")
print("            }")
print("        ")
print("        # Processar a resposta")
print("        script_content = response.text.strip()")
print("        ")
print("        return {")
print("            'success': True,")
print("            'script': script_content")
print("        }")
print("    except Exception as e:")
print("        print(f\"‚ùå Erro ao gerar roteiro com Gemini: {str(e)}\")")
print("        ")
print("        # SLEEP DE 2 SEGUNDOS EM CASO DE ERRO PARA EVITAR SOBRECARREGAR A API")
print("        time.sleep(2)")
print("        ")
print("        return {")
print("            'success': False,")
print("            'error': f'Erro ao gerar roteiro com Gemini: {str(e)}'")
print("        }")
print("\n----------------------------------------")
print("\n2. PARA A FUN√á√ÉO get_next_gemini_key NO ARQUIVO routes/automations.py:")
print("\n# C√≥digo a ser implementado:")
print("import time")
print("")
print("def get_next_gemini_key():")
print("    \"\"\"Obter pr√≥xima chave Gemini na rota√ß√£o com sleep para evitar rate limiting\"\"\"")
print("    # Carregar chaves se n√£o estiverem carregadas")
print("    if not GEMINI_KEYS_ROTATION['keys']:")
print("        load_gemini_keys()")
print("    ")
print("    # Reset di√°rio do contador
print("    today = datetime.now().date()")
print("    if GEMINI_KEYS_ROTATION['last_reset'] != today:")
print("        GEMINI_KEYS_ROTATION['usage_count'] = {}")
print("        GEMINI_KEYS_ROTATION['last_reset'] = today")
print("        GEMINI_KEYS_ROTATION['current_index'] = 0")
print("        print(\"üîÑ Reset di√°rio do contador de uso das chaves Gemini\")
print("        add_real_time_log(\"üîÑ Reset di√°rio do contador de uso das chaves Gemini\", \"info\", \"gemini-rotation\")")
print("    ")
print("    keys = GEMINI_KEYS_ROTATION['keys']")
print("    if not keys:")
print("        return None")
print("    ")
print("    # Encontrar chave com menor uso
print("    min_usage = float('inf')")
print("    best_key_index = 0
print("    ")
print("    for i, key in enumerate(keys):")
print("        usage = GEMINI_KEYS_ROTATION['usage_count'].get(key, 0)")
print("        if usage < min_usage:")
print("            min_usage = usage
print("            best_key_index = i
print("    ")
print("    # N√£o mais limitar arbitrariamente - as chaves ser√£o rotacionadas com base nos erros da API
print("    selected_key = keys[best_key_index]")
print("    ")
print("    # Incrementar contador de uso para fins de monitoramento
print("    GEMINI_KEYS_ROTATION['usage_count'][selected_key] = GEMINI_KEYS_ROTATION['usage_count'].get(selected_key, 0) + 1
print("    ")
print("    usage_count = GEMINI_KEYS_ROTATION['usage_count'][selected_key]")
print("    ")
print("    # Logs detalhados para debug
print("    print(f\"üîë Usando chave Gemini {best_key_index + 1}/{len(keys)} (uso total: {usage_count})\")
print("    print(f\"üîç [DEBUG] Chave selecionada: {selected_key[:20]}... (√≠ndice: {best_key_index})\")
print("    print(f\"üîç [DEBUG] Estado das chaves: {[(i, GEMINI_KEYS_ROTATION['usage_count'].get(key, 0)) for i, key in enumerate(keys)]}\")
print("    ")
print("    add_real_time_log(f\"üîë Usando chave Gemini {best_key_index + 1}/{len(keys)} (uso total: {usage_count})\", \"info\", \"gemini-rotation\")
print("    add_real_time_log(f\"üîç Chave: {selected_key[:20]}... (√≠ndice: {best_key_index})\", \"debug\", \"gemini-key-detail\")
print("    ")
print("    # SLEEP DE 0.5 SEGUNDOS ENTRE A SELE√á√ÉO DE CHAVES PARA EVITAR ROTA√á√ÉO MUITO R√ÅPIDA
print("    time.sleep(0.5)")
print("    ")
print("    return selected_key")
print("\n----------------------------------------")
print("\n3. PARA A FUN√á√ÉO handle_gemini_429_error COM BACKOFF EXPONENCIAL:")
print("\n# C√≥digo a ser implementado:")
print("import time")
print("")
print("def handle_gemini_429_error(key, attempt):")
print("    \"\"\"Tratar erro 429 (Quota excedida) com backoff exponencial\"\"\"")
print("    print(f\"‚ö†Ô∏è Quota excedida para a chave {key[:20]}... Tentativa {attempt}\")
print("    add_real_time_log(f\"‚ö†Ô∏è Quota excedida para chave Gemini (tentativa {attempt})\")
print("    ")
print("    # Marcar chave como esgotada por hoje
print("    GEMINI_KEYS_ROTATION['usage_count'][key] = 40  # Marcar como esgotada
print("    ")
print("    # IMPLEMENTAR BACKOFF EXPONENCIAL - TEMPO DE ESPERA CRESCENTE A CADA TENTATIVA
print("    # F√≥rmula: min(60 segundos, 1 segundo * (2 ** tentativa))
print("    backoff_time = min(60, 1 * (2 ** attempt))")
print("    ")
print("    print(f\"‚è±Ô∏è Aguardando {backoff_time:.1f} segundos antes de tentar pr√≥xima chave...\")
print("    time.sleep(backoff_time)")
print("    ")
print("    # Verificar se ainda h√° chaves dispon√≠veis
print("    available_keys = [k for k, v in GEMINI_KEYS_ROTATION['usage_count'].items() if v < 40]")
print("    ")
print("    if len(available_keys) == 0:")
print("        print(\"‚ö†Ô∏è Todas as chaves Gemini esgotadas. Ativando fallback para OpenAI.\")
print("        add_real_time_log(\"‚ö†Ô∏è Todas as chaves Gemini esgotadas. Fallback para OpenAI ativado.\", \"warning\")
print("        return False")
print("    ")
print("    return True")
print("\n----------------------------------------")
print("\nüõ†Ô∏è BENEF√çCIOS DA IMPLEMENTA√á√ÉO DE SLEEP:")
print("- Menos erros de rate limiting (429)")
print("- Melhor distribui√ß√£o de requisi√ß√µes entre as chaves")
print("- Menor probabilidade de quotas serem esgotadas prematuramente")
print("- Mais estabilidade no sistema de gera√ß√£o de conte√∫do")
print("\nüìù INSTRU√á√ïES DE IMPLEMENTA√á√ÉO:")
print("1. Abra os arquivos correspondentes no seu editor de c√≥digo")
print("2. Adicione a importa√ß√£o do m√≥dulo 'time' no in√≠cio das fun√ß√µes")
print("3. Cole os trechos de c√≥digo com as chamadas de time.sleep()")
print("4. Salve as altera√ß√µes")
print("5. Reinicie o backend para que as altera√ß√µes tenham efeito")
print("\n‚úÖ SISTEMA AGORA EST√Å COMPLETO!")
print("- Limite de 40 requisi√ß√µes por chave implementado")
print("- Rota√ß√£o de chaves funcionando corretamente")
print("- Frontend exibindo informa√ß√µes corretas")
print("- Implementa√ß√£o de sleep/aguardo pronta para ser adicionada")
print("\n=============================================")